# -*- coding: utf-8 -*-
"""Python_Finance.py

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1o-_ng53vE50GSfZ2fQIRSYIsZyi1SjGV
"""

#Description: This is a python program for finance
#             This program will show you how to compute portfolio simple returns, 
#             get daily returns and volatility etc.           
#https://medium.com/@randerson112358/python-for-finance-portfolio-optimization-66882498847

#import Libraries: 
from datetime import datetime
import numpy as np
import pandas as pd
import pandas_datareader as web 
import matplotlib.pyplot as plt 
plt.style.use('fivethirtyeight')

#this program attemps to to optimize a users portfolio usining the efficient Frontier (Selecting the best portfolio)
#maximises factors such a expected return and minismises cost such as financial risk

# Import the python libraries
from pandas_datareader import data as web
import pandas as pd
import numpy as np
from datetime import datetime
import matplotlib.pyplot as plt
plt.style.use('fivethirtyeight')

#get the stock symbols/ tickers in the portfolio 
# FAANG 
assets = ['FB', 'AMZN', 'AAPL', 'NFLX', 'GOOG']

# Assign weights to the stocks in the portfolio, the weight must = 1 (as percentage of FAANG portfolio)
weights = np.array([0.2, 0.2, 0.2, 0.2, 0.2])
#showing 20% of our invesment is in each stock

# get the start date of the portfolio 
stockStartDate = '2013-01-01'

# Get the stock ending date (today)

today = datetime.today().strftime('%Y-%m-%d')
today
#date formate

# Createe a dataframe to store the adjusted close proce of the stock
df = pd.DataFrame()

#Store the adjusted close price of the stock into the df
for stock in assets:
  df[stock] = web.DataReader(stock, data_source='yahoo', start = stockStartDate, end = today)['Adj Close']

# show the df collected from Yahoo for the adj close values for FAANG
df

#visualy show the stock / portfolio 

title = 'Portfolio Adj. Close Price History'

#Get my stocks

my_stocks = df

#Create and plot graph 
for c in my_stocks.columns.values:
  plt.plot(my_stocks[c], label = c)

plt.title(title)
plt.xlabel('Date,', fontsize = 18)
plt.ylabel('Adj. Price USD ($)', fontsize = 18)
plt.legend(my_stocks.columns.values, loc= 'upper left')

#show the daily simple return 
returns = df.pct_change()
returns

# returns equation(the new price/old price) -1

#Create and show annualized covariance matrix 
#(is a math concept in stats to determine how two random variable vary/ move together. the directional relatioship bet two asset prices)
#(252 is no of trading days) 
cov_matrix_annual = returns.cov() * 252 
cov_matrix_annual
# on the diagainal shows the variance(is the measure how a set of observations differ from each other) 2root of variance = volitility  
#everthing else show co-variance ()

#Calculate the portfolio variance 
port_variance = np.dot(weights.T, np.dot(cov_matrix_annual, weights))
# formula = the weights transposesed * co-variance matrrix * the weights 
port_variance

#calculate portfolio volatility aka standard deviation 
# volatilitiy = 2root of variance 
port_volatility = np.sqrt(port_variance)
port_volatility

#annual portfolio return 
portfolioSimpleAnnualReturn = np.sum(returns.mean() * weights) * 252
portfolioSimpleAnnualReturn

#show the expected annual return , volatitility (risk), and variance

percent_var = str( round(port_variance, 2) * 100) +'%'
percent_vols = str(round(port_volatility, 2) * 100)+ '%'
percent_ret = str(round(portfolioSimpleAnnualReturn, 2) * 100) + '%'

print('Expected annual return: '+ percent_ret)
print('Annual volatility / Risk: ' + percent_vols)
print('Annual variance: '+ percent_var)

pip install PyportfolioOpt

from pypfopt.efficient_frontier import EfficientFrontier
from pypfopt import risk_models
from pypfopt import expected_returns

#portfolio optimisation 

#calculate expected returns and annualised sample covariance matrix of asset returns 

mu = expected_returns.mean_historical_return(df)#returns.mean() * 252
S = risk_models.sample_cov(df) #Get the sample covariance matrix

#optimize for max sharpe ratio
#sharpe ratio = measures the performance of an investment compared to a risk-free asset, after adjusting for its risk

ef = EfficientFrontier(mu, S)
weights = ef.max_sharpe() #Maximize the Sharpe ratio, and get the raw weights #effcient frointier weights
cleaned_weights = ef.clean_weights() 
print(cleaned_weights) #Note the weights may have some rounding error, meaning they may not add up exactly to 1 but should be close #for true value remove cleaned_weights
ef.portfolio_performance(verbose=True)

0.1209 + 0.32815 + 0.22299 + 0.32796 + 0.0

#testing to see if it equals 1

# Get the discrete allocation of each share per stock 
from pypfopt.discrete_allocation import DiscreteAllocation, get_latest_prices 

latest_prices = get_latest_prices(df)
weights = cleaned_weights #double check [34]l6 for weight change 
da = DiscreteAllocation(weights, latest_prices, total_portfolio_value = 150000) #the amount of money willing to invest 

allocation , leftover = da.lp_portfolio()
print('Discrete allocation: ' , allocation)
print('Funds remaining: ${:.2f}'.format(leftover))

"""the above shows how many shares can be bought with a given set of funds in dollars US. In a weighted optimized format to optimize the purchase using sharpes ratio .

while giving you the remaining funds 



"""